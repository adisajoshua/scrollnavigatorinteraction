/**
 * ChatInterface Component
 * 
 * Purpose: Main interaction area for conversational finance.
 * Features: Message threads, skeleton loading, ScrollTimeline integration, honest data.
 * Dependencies: ScrollTimeline, Skeleton, Lucide icons.
 * 
 * @author Antigravity
 * @created 2026-01-16
 */

import React, { useState, useRef, useEffect } from 'react';
import { Send, ThumbsUp, ThumbsDown, Check } from 'lucide-react';
import ScrollTimeline from './ScrollTimeline';
import Skeleton from './Skeleton';
import './ChatInterface.css';

const MESSAGES = [
    {
        id: 'msg-1',
        sender: 'user',
        text: 'What is DeFi and how does it work?',
        time: '03:45 PM',
    },
    {
        id: 'msg-2',
        sender: 'ai',
        text: 'DeFi (Decentralized Finance) uses blockchain technology to remove intermediaries like banks from financial transactions. Through smart contracts on networks like Solana, you can lend, borrow, and trade assets directly with other users.',
        time: '03:45 PM',
    },
    {
        id: 'msg-3',
        sender: 'user',
        text: 'How is my 18% APY calculated?',
        time: '03:47 PM',
    },
    {
        id: 'msg-4',
        sender: 'ai',
        text: 'Your yield is generated by lending USDC to the Solend and Marginfi protocols. The 18% APY fluctuates based on pool demand. With your $11,000 balance, you\'re currently on track to earn $165.00 this month.',
        time: '03:48 PM',
    },
    {
        id: 'msg-5',
        sender: 'user',
        text: 'Is there a risk of losing my principal?',
        time: '03:50 PM',
    },
    {
        id: 'msg-6',
        sender: 'ai',
        text: 'Yes, like all DeFi, there are smart contract and platform risks. However, RebelFi protects your principal by diversifying across top-tier audited protocols and maintaining a $2M insurance fund for extreme market events.',
        time: '03:50 PM',
    },
    {
        id: 'msg-7',
        sender: 'user',
        text: 'What are the gas fees like on Solana?',
        time: '03:52 PM',
    },
    {
        id: 'msg-8',
        sender: 'ai',
        text: 'Solana gas fees (transaction fees) are extremely low, typically costing less than $0.001 per transaction. This makes it ideal for frequent rebalancing and smaller deposits compared to high-fee networks like Ethereum.',
        time: '03:53 PM',
    },
    {
        id: 'msg-9',
        sender: 'user',
        text: 'Tell me about liquid staking options.',
        time: '03:55 PM',
    },
    {
        id: 'msg-10',
        sender: 'ai',
        text: 'We support JitoSOL and mSOL. Liquid staking allows you to earn SOL staking rewards (~7-8%) while keeping your assets "liquid" via a receipt token, which you can then use here in RebelFi to earn additional lending yield.',
        time: '03:56 PM',
    },
    {
        id: 'msg-11',
        sender: 'user',
        text: 'How often are security audits performed?',
        time: '03:58 PM',
    },
    {
        id: 'msg-12',
        sender: 'ai',
        text: 'Our core smart contracts are audited quarterly by top firms like OtterSec and Kudelski Security. We also run a 24/7 bug bounty program via Immunefi to ensure continuous monitoring by white-hat hackers.',
        time: '03:59 PM',
    },
    {
        id: 'msg-13',
        sender: 'user',
        text: 'Could I suffer from Impermanent Loss here?',
        time: '04:02 PM',
    },
    {
        id: 'msg-14',
        sender: 'ai',
        text: 'Currently, you are only in lending pools (USDC), so there is **zero risk** of Impermanent Loss. IL only occurs in Liquidity Provider (LP) pairs like SOL/USDC when price ratios change significantly.',
        time: '04:03 PM',
    },
    {
        id: 'msg-15',
        sender: 'user',
        text: 'Is yield farming better than lending?',
        time: '04:05 PM',
    },
    {
        id: 'msg-16',
        sender: 'ai',
        text: 'Lending is safer and more "set-and-forget." Yield farming often involves more complexity and risks, but can offer higher rewards (30%+ APY) during high-incentive periods. We can help you transition if you want more risk.',
        time: '04:06 PM',
    },
    {
        id: 'msg-17',
        sender: 'user',
        text: 'Do you have a governance token?',
        time: '04:08 PM',
    },
    {
        id: 'msg-18',
        sender: 'ai',
        text: 'RebelFi does not currently have a token. We are focused on building a robust platform first. Any future governance plans will be announced via our official dashboard and verified social channels.',
        time: '04:09 PM',
    },
    {
        id: 'msg-19',
        sender: 'user',
        text: 'How should I secure my recovery phrase?',
        time: '04:12 PM',
    },
    {
        id: 'msg-20',
        sender: 'ai',
        text: 'Never store it digitally. We recommend writing it on physical paper and storing it in a fireproof safe. For large balances like yours ($11,000), consider using a hardware wallet like Ledger or Trezor for added security.',
        time: '04:13 PM',
    },
    {
        id: 'msg-21',
        sender: 'user',
        text: 'What is the safest stablecoin?',
        time: '04:15 PM',
    },
    {
        id: 'msg-22',
        sender: 'ai',
        text: 'We primarily use USDC (Circle) because it is fully reserved and audited in the US. While USDT is more liquid, USDC provides a higher degree of regulatory clarity and transparency for our risk management standards.',
        time: '04:16 PM',
    },
    {
        id: 'msg-23',
        sender: 'user',
        text: 'What is on the roadmap for Q1?',
        time: '04:20 PM',
    },
    {
        id: 'msg-24',
        sender: 'ai',
        text: 'Q1 focus is on automated vault strategies and our mobile-native app. We\'re also integrating with Jupiter for better rebalancing prices. Stay tuned for the Beta invite in your inbox next month!',
        time: '04:21 PM',
    }
];

const MessageBubble = ({ message, isLoading }) => {
    const isUser = message?.sender === 'user';

    if (isLoading) {
        return (
            <div className="message-row ai">
                <div className="ai-avatar ai-avatar--skeleton" />
                <div className="message-bubble message-bubble--skeleton">
                    <Skeleton width="80%" height="16px" />
                    <Skeleton width="60%" height="16px" />
                    <div className="message-meta">
                        <Skeleton width="40px" height="12px" />
                    </div>
                </div>
            </div>
        );
    }

    const renderContent = (text) => {
        return text.split('\n').map((line, i) => (
            <div key={i} className="message-line">
                {line.split('**').map((part, j) =>
                    j % 2 === 1 ? <strong key={j}>{part}</strong> : part
                )}
            </div>
        ));
    };

    return (
        <div id={message.id} className={`message-row ${message.sender}`}>
            {!isUser && <div className="ai-avatar">R</div>}

            <div className="message-bubble">
                <div className="message-content">
                    {renderContent(message.text)}
                </div>

                {message.action && (
                    <button className="action-btn">
                        {message.action}
                    </button>
                )}

                <div className="message-meta">
                    <span>{message.time}</span>
                    <Check size={14} className="status-icon" />
                    {!isUser && (
                        <div className="feedback-actions">
                            <button className="feedback-btn" aria-label="Helpful"><ThumbsUp size={14} /></button>
                            <button className="feedback-btn" aria-label="Not helpful"><ThumbsDown size={14} /></button>
                        </div>
                    )}
                </div>
            </div>
        </div>
    );
};

const ChatInterface = () => {
    const [inputValue, setInputValue] = useState('');
    const [isInitialLoading, setIsInitialLoading] = useState(true);
    const messagesAreaRef = useRef(null);

    // Simulate initial load for Skeleton demo
    useEffect(() => {
        const timer = setTimeout(() => setIsInitialLoading(false), 1500);
        return () => clearTimeout(timer);
    }, []);

    const userMessages = MESSAGES.filter(msg => msg.sender === 'user');

    return (
        <section className="chat-interface">
            <div className="messages-area" ref={messagesAreaRef}>
                {isInitialLoading ? (
                    <>
                        <MessageBubble isLoading />
                        <MessageBubble isLoading />
                    </>
                ) : (
                    MESSAGES.map(msg => (
                        <MessageBubble key={msg.id} message={msg} />
                    ))
                )}
            </div>

            <ScrollTimeline
                messages={userMessages}
                messagesAreaRef={messagesAreaRef}
            />

            <div className="input-section">
                <div className="input-wrapper">
                    <input
                        type="text"
                        className="chat-input"
                        placeholder="Type a message or ask about your yield..."
                        value={inputValue}
                        onChange={(e) => setInputValue(e.target.value)}
                    />
                    <button className="send-button" aria-label="Send message">
                        <Send size={20} />
                    </button>
                </div>
            </div>
        </section>
    );
};

export default ChatInterface;
